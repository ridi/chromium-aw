// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sampled_profile.proto

package org.chromium.components.metrics;

public final class SampledProfileProtos {
  private SampledProfileProtos() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }
  public interface SampledProfileOrBuilder extends
      // @@protoc_insertion_point(interface_extends:metrics.SampledProfile)
      com.google.protobuf.MessageLiteOrBuilder {

    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     * @return Whether the triggerEvent field is set.
     */
    boolean hasTriggerEvent();
    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     * @return The triggerEvent.
     */
    org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent getTriggerEvent();

    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     * @return Whether the process field is set.
     */
    boolean hasProcess();
    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     * @return The process.
     */
    org.chromium.components.metrics.ExecutionContextProtos.Process getProcess();

    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     * @return Whether the thread field is set.
     */
    boolean hasThread();
    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     * @return The thread.
     */
    org.chromium.components.metrics.ExecutionContextProtos.Thread getThread();

    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    int getProcessTypesCount();
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    boolean containsProcessTypes(
        int key);
    /**
     * Use {@link #getProcessTypesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
    getProcessTypes();
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
    getProcessTypesMap();
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrDefault(
        int key,
        org.chromium.components.metrics.ExecutionContextProtos.Process defaultValue);
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrThrow(
        int key);

    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    int getThreadTypesCount();
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    boolean containsThreadTypes(
        int key);
    /**
     * Use {@link #getThreadTypesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
    getThreadTypes();
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
    getThreadTypesMap();
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrDefault(
        int key,
        org.chromium.components.metrics.ExecutionContextProtos.Thread defaultValue);
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrThrow(
        int key);

    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     * @return Whether the msAfterBoot field is set.
     */
    boolean hasMsAfterBoot();
    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     * @return The msAfterBoot.
     */
    long getMsAfterBoot();

    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     * @return Whether the msAfterLogin field is set.
     */
    boolean hasMsAfterLogin();
    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     * @return The msAfterLogin.
     */
    long getMsAfterLogin();

    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     * @return Whether the suspendDurationMs field is set.
     */
    boolean hasSuspendDurationMs();
    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     * @return The suspendDurationMs.
     */
    long getSuspendDurationMs();

    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     * @return Whether the msAfterResume field is set.
     */
    boolean hasMsAfterResume();
    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     * @return The msAfterResume.
     */
    long getMsAfterResume();

    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     * @return Whether the numTabsRestored field is set.
     */
    boolean hasNumTabsRestored();
    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     * @return The numTabsRestored.
     */
    int getNumTabsRestored();

    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     * @return Whether the msAfterRestore field is set.
     */
    boolean hasMsAfterRestore();
    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     * @return The msAfterRestore.
     */
    long getMsAfterRestore();

    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     * @return Whether the perfData field is set.
     */
    boolean hasPerfData();
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     * @return The perfData.
     */
    org.chromium.components.metrics.PerfDataProtos.PerfDataProto getPerfData();

    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     * @return Whether the callStackProfile field is set.
     */
    boolean hasCallStackProfile();
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     * @return The callStackProfile.
     */
    org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile getCallStackProfile();

    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     * @return Whether the perfStat field is set.
     */
    boolean hasPerfStat();
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     * @return The perfStat.
     */
    org.chromium.components.metrics.PerfStat.PerfStatProto getPerfStat();

    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @return A list containing the cpuMaxFrequencyMhz.
     */
    java.util.List<java.lang.Integer> getCpuMaxFrequencyMhzList();
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @return The count of cpuMaxFrequencyMhz.
     */
    int getCpuMaxFrequencyMhzCount();
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @param index The index of the element to return.
     * @return The cpuMaxFrequencyMhz at the given index.
     */
    int getCpuMaxFrequencyMhz(int index);
  }
  /**
   * <pre>
   * Next tag: 16
   * </pre>
   *
   * Protobuf type {@code metrics.SampledProfile}
   */
  public  static final class SampledProfile extends
      com.google.protobuf.GeneratedMessageLite<
          SampledProfile, SampledProfile.Builder> implements
      // @@protoc_insertion_point(message_implements:metrics.SampledProfile)
      SampledProfileOrBuilder {
    private SampledProfile() {
      cpuMaxFrequencyMhz_ = emptyIntList();
    }
    /**
     * <pre>
     * Indicates the event that triggered this collection.
     * </pre>
     *
     * Protobuf enum {@code metrics.SampledProfile.TriggerEvent}
     */
    public enum TriggerEvent
        implements com.google.protobuf.Internal.EnumLite {
      /**
       * <code>UNKNOWN_TRIGGER_EVENT = 0;</code>
       */
      UNKNOWN_TRIGGER_EVENT(0),
      /**
       * <pre>
       * The profile was triggered by periodic sampling.  Periodically sampled
       * profiles are collected once per uniformly sized period interval.  Within
       * each interval, the sampled data is collected at a random time.  For
       * example, if the interval is 60 s, then data would be collected at a
       * random point in each of the intervals [0, 60 s), [60 s, 120 s), etc.
       * </pre>
       *
       * <code>PERIODIC_COLLECTION = 1;</code>
       */
      PERIODIC_COLLECTION(1),
      /**
       * <pre>
       * The profile was collected upon resume from suspend.
       * </pre>
       *
       * <code>RESUME_FROM_SUSPEND = 2;</code>
       */
      RESUME_FROM_SUSPEND(2),
      /**
       * <pre>
       * The profile was collected upon restoring a previous session.
       * </pre>
       *
       * <code>RESTORE_SESSION = 3;</code>
       */
      RESTORE_SESSION(3),
      /**
       * <pre>
       * The profile was collected at process startup.
       * </pre>
       *
       * <code>PROCESS_STARTUP = 4;</code>
       */
      PROCESS_STARTUP(4),
      /**
       * <pre>
       * The profile was collected after jank was detected while executing a task.
       * </pre>
       *
       * <code>JANKY_TASK = 5;</code>
       */
      JANKY_TASK(5),
      /**
       * <pre>
       * The profile was collected after a thread was determined to be hung.
       * </pre>
       *
       * <code>THREAD_HUNG = 6;</code>
       */
      THREAD_HUNG(6),
      /**
       * <pre>
       * The heap profile was triggered by periodic sampling. The time intervals
       * between trigger events conform to the Poisson process with certain mean
       * interval between collections.
       * </pre>
       *
       * <code>PERIODIC_HEAP_COLLECTION = 7;</code>
       */
      PERIODIC_HEAP_COLLECTION(7),
      ;

      /**
       * <code>UNKNOWN_TRIGGER_EVENT = 0;</code>
       */
      public static final int UNKNOWN_TRIGGER_EVENT_VALUE = 0;
      /**
       * <pre>
       * The profile was triggered by periodic sampling.  Periodically sampled
       * profiles are collected once per uniformly sized period interval.  Within
       * each interval, the sampled data is collected at a random time.  For
       * example, if the interval is 60 s, then data would be collected at a
       * random point in each of the intervals [0, 60 s), [60 s, 120 s), etc.
       * </pre>
       *
       * <code>PERIODIC_COLLECTION = 1;</code>
       */
      public static final int PERIODIC_COLLECTION_VALUE = 1;
      /**
       * <pre>
       * The profile was collected upon resume from suspend.
       * </pre>
       *
       * <code>RESUME_FROM_SUSPEND = 2;</code>
       */
      public static final int RESUME_FROM_SUSPEND_VALUE = 2;
      /**
       * <pre>
       * The profile was collected upon restoring a previous session.
       * </pre>
       *
       * <code>RESTORE_SESSION = 3;</code>
       */
      public static final int RESTORE_SESSION_VALUE = 3;
      /**
       * <pre>
       * The profile was collected at process startup.
       * </pre>
       *
       * <code>PROCESS_STARTUP = 4;</code>
       */
      public static final int PROCESS_STARTUP_VALUE = 4;
      /**
       * <pre>
       * The profile was collected after jank was detected while executing a task.
       * </pre>
       *
       * <code>JANKY_TASK = 5;</code>
       */
      public static final int JANKY_TASK_VALUE = 5;
      /**
       * <pre>
       * The profile was collected after a thread was determined to be hung.
       * </pre>
       *
       * <code>THREAD_HUNG = 6;</code>
       */
      public static final int THREAD_HUNG_VALUE = 6;
      /**
       * <pre>
       * The heap profile was triggered by periodic sampling. The time intervals
       * between trigger events conform to the Poisson process with certain mean
       * interval between collections.
       * </pre>
       *
       * <code>PERIODIC_HEAP_COLLECTION = 7;</code>
       */
      public static final int PERIODIC_HEAP_COLLECTION_VALUE = 7;


      @java.lang.Override
      public final int getNumber() {
        return value;
      }

      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static TriggerEvent valueOf(int value) {
        return forNumber(value);
      }

      public static TriggerEvent forNumber(int value) {
        switch (value) {
          case 0: return UNKNOWN_TRIGGER_EVENT;
          case 1: return PERIODIC_COLLECTION;
          case 2: return RESUME_FROM_SUSPEND;
          case 3: return RESTORE_SESSION;
          case 4: return PROCESS_STARTUP;
          case 5: return JANKY_TASK;
          case 6: return THREAD_HUNG;
          case 7: return PERIODIC_HEAP_COLLECTION;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<TriggerEvent>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          TriggerEvent> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<TriggerEvent>() {
              @java.lang.Override
              public TriggerEvent findValueByNumber(int number) {
                return TriggerEvent.forNumber(number);
              }
            };

      public static com.google.protobuf.Internal.EnumVerifier 
          internalGetVerifier() {
        return TriggerEventVerifier.INSTANCE;
      }

      private static final class TriggerEventVerifier implements 
           com.google.protobuf.Internal.EnumVerifier { 
              static final com.google.protobuf.Internal.EnumVerifier           INSTANCE = new TriggerEventVerifier();
              @java.lang.Override
              public boolean isInRange(int number) {
                return TriggerEvent.forNumber(number) != null;
              }
            };

      private final int value;

      private TriggerEvent(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:metrics.SampledProfile.TriggerEvent)
    }

    private int bitField0_;
    public static final int TRIGGER_EVENT_FIELD_NUMBER = 1;
    private int triggerEvent_;
    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     * @return Whether the triggerEvent field is set.
     */
    @java.lang.Override
    public boolean hasTriggerEvent() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     * @return The triggerEvent.
     */
    @java.lang.Override
    public org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent getTriggerEvent() {
      org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent result = org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent.forNumber(triggerEvent_);
      return result == null ? org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent.UNKNOWN_TRIGGER_EVENT : result;
    }
    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     * @param value The triggerEvent to set.
     */
    private void setTriggerEvent(org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent value) {
      triggerEvent_ = value.getNumber();
      bitField0_ |= 0x00000001;
    }
    /**
     * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
     */
    private void clearTriggerEvent() {
      bitField0_ = (bitField0_ & ~0x00000001);
      triggerEvent_ = 0;
    }

    public static final int PROCESS_FIELD_NUMBER = 11;
    private int process_;
    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     * @return Whether the process field is set.
     */
    @java.lang.Override
    public boolean hasProcess() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     * @return The process.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExecutionContextProtos.Process getProcess() {
      org.chromium.components.metrics.ExecutionContextProtos.Process result = org.chromium.components.metrics.ExecutionContextProtos.Process.forNumber(process_);
      return result == null ? org.chromium.components.metrics.ExecutionContextProtos.Process.UNKNOWN_PROCESS : result;
    }
    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     * @param value The process to set.
     */
    private void setProcess(org.chromium.components.metrics.ExecutionContextProtos.Process value) {
      process_ = value.getNumber();
      bitField0_ |= 0x00000002;
    }
    /**
     * <pre>
     * The process in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Process process = 11;</code>
     */
    private void clearProcess() {
      bitField0_ = (bitField0_ & ~0x00000002);
      process_ = 0;
    }

    public static final int THREAD_FIELD_NUMBER = 12;
    private int thread_;
    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     * @return Whether the thread field is set.
     */
    @java.lang.Override
    public boolean hasThread() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     * @return The thread.
     */
    @java.lang.Override
    public org.chromium.components.metrics.ExecutionContextProtos.Thread getThread() {
      org.chromium.components.metrics.ExecutionContextProtos.Thread result = org.chromium.components.metrics.ExecutionContextProtos.Thread.forNumber(thread_);
      return result == null ? org.chromium.components.metrics.ExecutionContextProtos.Thread.UNKNOWN_THREAD : result;
    }
    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     * @param value The thread to set.
     */
    private void setThread(org.chromium.components.metrics.ExecutionContextProtos.Thread value) {
      thread_ = value.getNumber();
      bitField0_ |= 0x00000004;
    }
    /**
     * <pre>
     * The thread in which the profile was collected.
     * </pre>
     *
     * <code>optional .metrics.Thread thread = 12;</code>
     */
    private void clearThread() {
      bitField0_ = (bitField0_ & ~0x00000004);
      thread_ = 0;
    }

    public static final int PROCESS_TYPES_FIELD_NUMBER = 13;
    private static final class ProcessTypesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  org.chromium.components.metrics.ExecutionContextProtos.Process.UNKNOWN_PROCESS.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.Integer> processTypes_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetProcessTypes() {
      return processTypes_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetMutableProcessTypes() {
      if (!processTypes_.isMutable()) {
        processTypes_ = processTypes_.mutableCopy();
      }
      return processTypes_;
    }
    @java.lang.Override

    public int getProcessTypesCount() {
      return internalGetProcessTypes().size();
    }
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    @java.lang.Override

    public boolean containsProcessTypes(
        int key) {
      
      return internalGetProcessTypes().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process> processTypesValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                org.chromium.components.metrics.ExecutionContextProtos.Process.internalGetValueMap(),
                org.chromium.components.metrics.ExecutionContextProtos.Process.UNKNOWN_PROCESS);
    /**
     * Use {@link #getProcessTypesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
    getProcessTypes() {
      return getProcessTypesMap();
    }
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
    getProcessTypesMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process, java.lang.Integer>(
                internalGetProcessTypes(),
                processTypesValueConverter));
    }
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    @java.lang.Override

    public org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrDefault(
        int key,
        org.chromium.components.metrics.ExecutionContextProtos.Process defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetProcessTypes();
      return map.containsKey(key)
             ? processTypesValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    @java.lang.Override

    public org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetProcessTypes();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return processTypesValueConverter.doForward(map.get(key));
    }
    /**
     * <pre>
     * Map of Chrome PIDs running on the system when the profile was collected.
     * Each Chrome PID is mapped to its process type.
     * This field and the below thread_types field assume that the PID/TID
     * information are collected in a short duration for a single session such
     * that, the PID/TID reuse is highly unlikely.
     * The information from these two fields is used to map chrome samples
     * collected for a specific PID/TID to the corresponding process type and
     * thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
     */
    private java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
    getMutableProcessTypesMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process, java.lang.Integer>(
              internalGetMutableProcessTypes(),
              processTypesValueConverter);
    }

    public static final int THREAD_TYPES_FIELD_NUMBER = 14;
    private static final class ThreadTypesDefaultEntryHolder {
      static final com.google.protobuf.MapEntryLite<
          java.lang.Integer, java.lang.Integer> defaultEntry =
              com.google.protobuf.MapEntryLite
              .<java.lang.Integer, java.lang.Integer>newDefaultInstance(
                  com.google.protobuf.WireFormat.FieldType.UINT32,
                  0,
                  com.google.protobuf.WireFormat.FieldType.ENUM,
                  org.chromium.components.metrics.ExecutionContextProtos.Thread.UNKNOWN_THREAD.getNumber());
    }
    private com.google.protobuf.MapFieldLite<
        java.lang.Integer, java.lang.Integer> threadTypes_ =
            com.google.protobuf.MapFieldLite.emptyMapField();
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetThreadTypes() {
      return threadTypes_;
    }
    private com.google.protobuf.MapFieldLite<java.lang.Integer, java.lang.Integer>
    internalGetMutableThreadTypes() {
      if (!threadTypes_.isMutable()) {
        threadTypes_ = threadTypes_.mutableCopy();
      }
      return threadTypes_;
    }
    @java.lang.Override

    public int getThreadTypesCount() {
      return internalGetThreadTypes().size();
    }
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    @java.lang.Override

    public boolean containsThreadTypes(
        int key) {
      
      return internalGetThreadTypes().containsKey(key);
    }
    private static final
    com.google.protobuf.Internal.MapAdapter.Converter<
        java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread> threadTypesValueConverter =
            com.google.protobuf.Internal.MapAdapter.newEnumConverter(
                org.chromium.components.metrics.ExecutionContextProtos.Thread.internalGetValueMap(),
                org.chromium.components.metrics.ExecutionContextProtos.Thread.UNKNOWN_THREAD);
    /**
     * Use {@link #getThreadTypesMap()} instead.
     */
    @java.lang.Deprecated
    public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
    getThreadTypes() {
      return getThreadTypesMap();
    }
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
    getThreadTypesMap() {
      return java.util.Collections.unmodifiableMap(
          new com.google.protobuf.Internal.MapAdapter<
            java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread, java.lang.Integer>(
                internalGetThreadTypes(),
                threadTypesValueConverter));
    }
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    @java.lang.Override

    public org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrDefault(
        int key,
        org.chromium.components.metrics.ExecutionContextProtos.Thread defaultValue) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetThreadTypes();
      return map.containsKey(key)
             ? threadTypesValueConverter.doForward(map.get(key))
             : defaultValue;
    }
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    @java.lang.Override

    public org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrThrow(
        int key) {
      
      java.util.Map<java.lang.Integer, java.lang.Integer> map =
          internalGetThreadTypes();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return threadTypesValueConverter.doForward(map.get(key));
    }
    /**
     * <pre>
     * Map of Chrome TIDs running on the system when the profile was collected.
     * Each Chrome TID is mapped to its thread type.
     * </pre>
     *
     * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
     */
    private java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
    getMutableThreadTypesMap() {
      return new com.google.protobuf.Internal.MapAdapter<
          java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread, java.lang.Integer>(
              internalGetMutableThreadTypes(),
              threadTypesValueConverter);
    }

    public static final int MS_AFTER_BOOT_FIELD_NUMBER = 2;
    private long msAfterBoot_;
    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     * @return Whether the msAfterBoot field is set.
     */
    @java.lang.Override
    public boolean hasMsAfterBoot() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     * @return The msAfterBoot.
     */
    @java.lang.Override
    public long getMsAfterBoot() {
      return msAfterBoot_;
    }
    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     * @param value The msAfterBoot to set.
     */
    private void setMsAfterBoot(long value) {
      bitField0_ |= 0x00000008;
      msAfterBoot_ = value;
    }
    /**
     * <pre>
     * Time after system boot when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_boot = 2;</code>
     */
    private void clearMsAfterBoot() {
      bitField0_ = (bitField0_ & ~0x00000008);
      msAfterBoot_ = 0L;
    }

    public static final int MS_AFTER_LOGIN_FIELD_NUMBER = 3;
    private long msAfterLogin_;
    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     * @return Whether the msAfterLogin field is set.
     */
    @java.lang.Override
    public boolean hasMsAfterLogin() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     * @return The msAfterLogin.
     */
    @java.lang.Override
    public long getMsAfterLogin() {
      return msAfterLogin_;
    }
    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     * @param value The msAfterLogin to set.
     */
    private void setMsAfterLogin(long value) {
      bitField0_ |= 0x00000010;
      msAfterLogin_ = value;
    }
    /**
     * <pre>
     * Time after last login when the collection took place, in milliseconds.
     * </pre>
     *
     * <code>optional int64 ms_after_login = 3;</code>
     */
    private void clearMsAfterLogin() {
      bitField0_ = (bitField0_ & ~0x00000010);
      msAfterLogin_ = 0L;
    }

    public static final int SUSPEND_DURATION_MS_FIELD_NUMBER = 5;
    private long suspendDurationMs_;
    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     * @return Whether the suspendDurationMs field is set.
     */
    @java.lang.Override
    public boolean hasSuspendDurationMs() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     * @return The suspendDurationMs.
     */
    @java.lang.Override
    public long getSuspendDurationMs() {
      return suspendDurationMs_;
    }
    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     * @param value The suspendDurationMs to set.
     */
    private void setSuspendDurationMs(long value) {
      bitField0_ |= 0x00000020;
      suspendDurationMs_ = value;
    }
    /**
     * <pre>
     * The duration for which the machine was suspended prior to collecting the
     * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 suspend_duration_ms = 5;</code>
     */
    private void clearSuspendDurationMs() {
      bitField0_ = (bitField0_ & ~0x00000020);
      suspendDurationMs_ = 0L;
    }

    public static final int MS_AFTER_RESUME_FIELD_NUMBER = 6;
    private long msAfterResume_;
    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     * @return Whether the msAfterResume field is set.
     */
    @java.lang.Override
    public boolean hasMsAfterResume() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     * @return The msAfterResume.
     */
    @java.lang.Override
    public long getMsAfterResume() {
      return msAfterResume_;
    }
    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     * @param value The msAfterResume to set.
     */
    private void setMsAfterResume(long value) {
      bitField0_ |= 0x00000040;
      msAfterResume_ = value;
    }
    /**
     * <pre>
     * Number of milliseconds after a resume that profile was collected. Only set
     * when |trigger_event| is RESUME_FROM_SUSPEND.
     * </pre>
     *
     * <code>optional int64 ms_after_resume = 6;</code>
     */
    private void clearMsAfterResume() {
      bitField0_ = (bitField0_ & ~0x00000040);
      msAfterResume_ = 0L;
    }

    public static final int NUM_TABS_RESTORED_FIELD_NUMBER = 7;
    private int numTabsRestored_;
    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     * @return Whether the numTabsRestored field is set.
     */
    @java.lang.Override
    public boolean hasNumTabsRestored() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     * @return The numTabsRestored.
     */
    @java.lang.Override
    public int getNumTabsRestored() {
      return numTabsRestored_;
    }
    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     * @param value The numTabsRestored to set.
     */
    private void setNumTabsRestored(int value) {
      bitField0_ |= 0x00000080;
      numTabsRestored_ = value;
    }
    /**
     * <pre>
     * Number of tabs restored during a session restore. Only set when
     * |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int32 num_tabs_restored = 7;</code>
     */
    private void clearNumTabsRestored() {
      bitField0_ = (bitField0_ & ~0x00000080);
      numTabsRestored_ = 0;
    }

    public static final int MS_AFTER_RESTORE_FIELD_NUMBER = 8;
    private long msAfterRestore_;
    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     * @return Whether the msAfterRestore field is set.
     */
    @java.lang.Override
    public boolean hasMsAfterRestore() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     * @return The msAfterRestore.
     */
    @java.lang.Override
    public long getMsAfterRestore() {
      return msAfterRestore_;
    }
    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     * @param value The msAfterRestore to set.
     */
    private void setMsAfterRestore(long value) {
      bitField0_ |= 0x00000100;
      msAfterRestore_ = value;
    }
    /**
     * <pre>
     * Number of milliseconds after a session restore that a profile was
     * collected. Only set when |trigger_event| is RESTORE_SESSION.
     * </pre>
     *
     * <code>optional int64 ms_after_restore = 8;</code>
     */
    private void clearMsAfterRestore() {
      bitField0_ = (bitField0_ & ~0x00000100);
      msAfterRestore_ = 0L;
    }

    public static final int PERF_DATA_FIELD_NUMBER = 4;
    private org.chromium.components.metrics.PerfDataProtos.PerfDataProto perfData_;
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     */
    @java.lang.Override
    public boolean hasPerfData() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.PerfDataProtos.PerfDataProto getPerfData() {
      return perfData_ == null ? org.chromium.components.metrics.PerfDataProtos.PerfDataProto.getDefaultInstance() : perfData_;
    }
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     */
    private void setPerfData(org.chromium.components.metrics.PerfDataProtos.PerfDataProto value) {
      value.getClass();
  perfData_ = value;
      bitField0_ |= 0x00000200;
      }
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePerfData(org.chromium.components.metrics.PerfDataProtos.PerfDataProto value) {
      value.getClass();
  if (perfData_ != null &&
          perfData_ != org.chromium.components.metrics.PerfDataProtos.PerfDataProto.getDefaultInstance()) {
        perfData_ =
          org.chromium.components.metrics.PerfDataProtos.PerfDataProto.newBuilder(perfData_).mergeFrom(value).buildPartial();
      } else {
        perfData_ = value;
      }
      bitField0_ |= 0x00000200;
    }
    /**
     * <pre>
     * Sampled profile data collected from Linux perf tool.
     * </pre>
     *
     * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
     */
    private void clearPerfData() {  perfData_ = null;
      bitField0_ = (bitField0_ & ~0x00000200);
    }

    public static final int CALL_STACK_PROFILE_FIELD_NUMBER = 9;
    private org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile callStackProfile_;
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     */
    @java.lang.Override
    public boolean hasCallStackProfile() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile getCallStackProfile() {
      return callStackProfile_ == null ? org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile.getDefaultInstance() : callStackProfile_;
    }
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     */
    private void setCallStackProfile(org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile value) {
      value.getClass();
  callStackProfile_ = value;
      bitField0_ |= 0x00000400;
      }
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergeCallStackProfile(org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile value) {
      value.getClass();
  if (callStackProfile_ != null &&
          callStackProfile_ != org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile.getDefaultInstance()) {
        callStackProfile_ =
          org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile.newBuilder(callStackProfile_).mergeFrom(value).buildPartial();
      } else {
        callStackProfile_ = value;
      }
      bitField0_ |= 0x00000400;
    }
    /**
     * <pre>
     * Sampled profile data collected by periodic sampling of call stacks.
     * </pre>
     *
     * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
     */
    private void clearCallStackProfile() {  callStackProfile_ = null;
      bitField0_ = (bitField0_ & ~0x00000400);
    }

    public static final int PERF_STAT_FIELD_NUMBER = 10;
    private org.chromium.components.metrics.PerfStat.PerfStatProto perfStat_;
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     */
    @java.lang.Override
    public boolean hasPerfStat() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     */
    @java.lang.Override
    public org.chromium.components.metrics.PerfStat.PerfStatProto getPerfStat() {
      return perfStat_ == null ? org.chromium.components.metrics.PerfStat.PerfStatProto.getDefaultInstance() : perfStat_;
    }
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     */
    private void setPerfStat(org.chromium.components.metrics.PerfStat.PerfStatProto value) {
      value.getClass();
  perfStat_ = value;
      bitField0_ |= 0x00000800;
      }
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     */
    @java.lang.SuppressWarnings({"ReferenceEquality"})
    private void mergePerfStat(org.chromium.components.metrics.PerfStat.PerfStatProto value) {
      value.getClass();
  if (perfStat_ != null &&
          perfStat_ != org.chromium.components.metrics.PerfStat.PerfStatProto.getDefaultInstance()) {
        perfStat_ =
          org.chromium.components.metrics.PerfStat.PerfStatProto.newBuilder(perfStat_).mergeFrom(value).buildPartial();
      } else {
        perfStat_ = value;
      }
      bitField0_ |= 0x00000800;
    }
    /**
     * <pre>
     * Perf counter data collected using "perf stat".
     * </pre>
     *
     * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
     */
    private void clearPerfStat() {  perfStat_ = null;
      bitField0_ = (bitField0_ & ~0x00000800);
    }

    public static final int CPU_MAX_FREQUENCY_MHZ_FIELD_NUMBER = 15;
    private com.google.protobuf.Internal.IntList cpuMaxFrequencyMhz_;
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @return A list containing the cpuMaxFrequencyMhz.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getCpuMaxFrequencyMhzList() {
      return cpuMaxFrequencyMhz_;
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @return The count of cpuMaxFrequencyMhz.
     */
    @java.lang.Override
    public int getCpuMaxFrequencyMhzCount() {
      return cpuMaxFrequencyMhz_.size();
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @param index The index of the element to return.
     * @return The cpuMaxFrequencyMhz at the given index.
     */
    @java.lang.Override
    public int getCpuMaxFrequencyMhz(int index) {
      return cpuMaxFrequencyMhz_.getInt(index);
    }
    private void ensureCpuMaxFrequencyMhzIsMutable() {
      com.google.protobuf.Internal.IntList tmp = cpuMaxFrequencyMhz_;
      if (!tmp.isModifiable()) {
        cpuMaxFrequencyMhz_ =
            com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
       }
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @param index The index to set the value at.
     * @param value The cpuMaxFrequencyMhz to set.
     */
    private void setCpuMaxFrequencyMhz(
        int index, int value) {
      ensureCpuMaxFrequencyMhzIsMutable();
      cpuMaxFrequencyMhz_.setInt(index, value);
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @param value The cpuMaxFrequencyMhz to add.
     */
    private void addCpuMaxFrequencyMhz(int value) {
      ensureCpuMaxFrequencyMhzIsMutable();
      cpuMaxFrequencyMhz_.addInt(value);
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     * @param values The cpuMaxFrequencyMhz to add.
     */
    private void addAllCpuMaxFrequencyMhz(
        java.lang.Iterable<? extends java.lang.Integer> values) {
      ensureCpuMaxFrequencyMhzIsMutable();
      com.google.protobuf.AbstractMessageLite.addAll(
          values, cpuMaxFrequencyMhz_);
    }
    /**
     * <pre>
     * The maximum frequency in MHz reported for each logical CPU on the device.
     * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
     * core 1, and so on. The field is optional and populated only for metrics
     * that can use the max frequency to compute a CPU utilization metric, e.g.
     * when measuring CPU cycles.
     * </pre>
     *
     * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
     */
    private void clearCpuMaxFrequencyMhz() {
      cpuMaxFrequencyMhz_ = emptyIntList();
    }

    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, data, extensionRegistry);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input);
    }
    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageLite.parseFrom(
          DEFAULT_INSTANCE, input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return (Builder) DEFAULT_INSTANCE.createBuilder();
    }
    public static Builder newBuilder(org.chromium.components.metrics.SampledProfileProtos.SampledProfile prototype) {
      return (Builder) DEFAULT_INSTANCE.createBuilder(prototype);
    }

    /**
     * <pre>
     * Next tag: 16
     * </pre>
     *
     * Protobuf type {@code metrics.SampledProfile}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageLite.Builder<
          org.chromium.components.metrics.SampledProfileProtos.SampledProfile, Builder> implements
        // @@protoc_insertion_point(builder_implements:metrics.SampledProfile)
        org.chromium.components.metrics.SampledProfileProtos.SampledProfileOrBuilder {
      // Construct using org.chromium.components.metrics.SampledProfileProtos.SampledProfile.newBuilder()
      private Builder() {
        super(DEFAULT_INSTANCE);
      }


      /**
       * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
       * @return Whether the triggerEvent field is set.
       */
      @java.lang.Override
      public boolean hasTriggerEvent() {
        return instance.hasTriggerEvent();
      }
      /**
       * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
       * @return The triggerEvent.
       */
      @java.lang.Override
      public org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent getTriggerEvent() {
        return instance.getTriggerEvent();
      }
      /**
       * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
       * @param value The enum numeric value on the wire for triggerEvent to set.
       * @return This builder for chaining.
       */
      public Builder setTriggerEvent(org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent value) {
        copyOnWrite();
        instance.setTriggerEvent(value);
        return this;
      }
      /**
       * <code>optional .metrics.SampledProfile.TriggerEvent trigger_event = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearTriggerEvent() {
        copyOnWrite();
        instance.clearTriggerEvent();
        return this;
      }

      /**
       * <pre>
       * The process in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Process process = 11;</code>
       * @return Whether the process field is set.
       */
      @java.lang.Override
      public boolean hasProcess() {
        return instance.hasProcess();
      }
      /**
       * <pre>
       * The process in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Process process = 11;</code>
       * @return The process.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExecutionContextProtos.Process getProcess() {
        return instance.getProcess();
      }
      /**
       * <pre>
       * The process in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Process process = 11;</code>
       * @param value The enum numeric value on the wire for process to set.
       * @return This builder for chaining.
       */
      public Builder setProcess(org.chromium.components.metrics.ExecutionContextProtos.Process value) {
        copyOnWrite();
        instance.setProcess(value);
        return this;
      }
      /**
       * <pre>
       * The process in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Process process = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearProcess() {
        copyOnWrite();
        instance.clearProcess();
        return this;
      }

      /**
       * <pre>
       * The thread in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Thread thread = 12;</code>
       * @return Whether the thread field is set.
       */
      @java.lang.Override
      public boolean hasThread() {
        return instance.hasThread();
      }
      /**
       * <pre>
       * The thread in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Thread thread = 12;</code>
       * @return The thread.
       */
      @java.lang.Override
      public org.chromium.components.metrics.ExecutionContextProtos.Thread getThread() {
        return instance.getThread();
      }
      /**
       * <pre>
       * The thread in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Thread thread = 12;</code>
       * @param value The enum numeric value on the wire for thread to set.
       * @return This builder for chaining.
       */
      public Builder setThread(org.chromium.components.metrics.ExecutionContextProtos.Thread value) {
        copyOnWrite();
        instance.setThread(value);
        return this;
      }
      /**
       * <pre>
       * The thread in which the profile was collected.
       * </pre>
       *
       * <code>optional .metrics.Thread thread = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearThread() {
        copyOnWrite();
        instance.clearThread();
        return this;
      }

      @java.lang.Override

      public int getProcessTypesCount() {
        return instance.getProcessTypesMap().size();
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      @java.lang.Override

      public boolean containsProcessTypes(
          int key) {
        
        return instance.getProcessTypesMap().containsKey(key);
      }

      public Builder clearProcessTypes() {
        copyOnWrite();
        instance.getMutableProcessTypesMap().clear();
        return this;
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */

      public Builder removeProcessTypes(
          int key) {
        
        copyOnWrite();
        instance.getMutableProcessTypesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getProcessTypesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
      getProcessTypes() {
        return getProcessTypesMap();
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process>
      getProcessTypesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getProcessTypesMap());
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      @java.lang.Override

      public org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrDefault(
          int key,
          org.chromium.components.metrics.ExecutionContextProtos.Process defaultValue) {
        
        java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process> map =
            instance.getProcessTypesMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      @java.lang.Override

      public org.chromium.components.metrics.ExecutionContextProtos.Process getProcessTypesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process> map =
            instance.getProcessTypesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      public Builder putProcessTypes(
          int key,
          org.chromium.components.metrics.ExecutionContextProtos.Process value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableProcessTypesMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Map of Chrome PIDs running on the system when the profile was collected.
       * Each Chrome PID is mapped to its process type.
       * This field and the below thread_types field assume that the PID/TID
       * information are collected in a short duration for a single session such
       * that, the PID/TID reuse is highly unlikely.
       * The information from these two fields is used to map chrome samples
       * collected for a specific PID/TID to the corresponding process type and
       * thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Process&gt; process_types = 13;</code>
       */
      public Builder putAllProcessTypes(
          java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Process> values) {
        copyOnWrite();
        instance.getMutableProcessTypesMap().putAll(values);
        return this;
      }

      @java.lang.Override

      public int getThreadTypesCount() {
        return instance.getThreadTypesMap().size();
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      @java.lang.Override

      public boolean containsThreadTypes(
          int key) {
        
        return instance.getThreadTypesMap().containsKey(key);
      }

      public Builder clearThreadTypes() {
        copyOnWrite();
        instance.getMutableThreadTypesMap().clear();
        return this;
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */

      public Builder removeThreadTypes(
          int key) {
        
        copyOnWrite();
        instance.getMutableThreadTypesMap().remove(key);
        return this;
      }
      /**
       * Use {@link #getThreadTypesMap()} instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
      getThreadTypes() {
        return getThreadTypesMap();
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread>
      getThreadTypesMap() {
        return java.util.Collections.unmodifiableMap(
            instance.getThreadTypesMap());
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      @java.lang.Override

      public org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrDefault(
          int key,
          org.chromium.components.metrics.ExecutionContextProtos.Thread defaultValue) {
        
        java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread> map =
            instance.getThreadTypesMap();
        return map.containsKey(key)
               ? map.get(key)
               : defaultValue;
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      @java.lang.Override

      public org.chromium.components.metrics.ExecutionContextProtos.Thread getThreadTypesOrThrow(
          int key) {
        
        java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread> map =
            instance.getThreadTypesMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      public Builder putThreadTypes(
          int key,
          org.chromium.components.metrics.ExecutionContextProtos.Thread value) {
        
        value.getClass();
        copyOnWrite();
        instance.getMutableThreadTypesMap().put(key, value);
        return this;
      }
      /**
       * <pre>
       * Map of Chrome TIDs running on the system when the profile was collected.
       * Each Chrome TID is mapped to its thread type.
       * </pre>
       *
       * <code>map&lt;uint32, .metrics.Thread&gt; thread_types = 14;</code>
       */
      public Builder putAllThreadTypes(
          java.util.Map<java.lang.Integer, org.chromium.components.metrics.ExecutionContextProtos.Thread> values) {
        copyOnWrite();
        instance.getMutableThreadTypesMap().putAll(values);
        return this;
      }

      /**
       * <pre>
       * Time after system boot when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_boot = 2;</code>
       * @return Whether the msAfterBoot field is set.
       */
      @java.lang.Override
      public boolean hasMsAfterBoot() {
        return instance.hasMsAfterBoot();
      }
      /**
       * <pre>
       * Time after system boot when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_boot = 2;</code>
       * @return The msAfterBoot.
       */
      @java.lang.Override
      public long getMsAfterBoot() {
        return instance.getMsAfterBoot();
      }
      /**
       * <pre>
       * Time after system boot when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_boot = 2;</code>
       * @param value The msAfterBoot to set.
       * @return This builder for chaining.
       */
      public Builder setMsAfterBoot(long value) {
        copyOnWrite();
        instance.setMsAfterBoot(value);
        return this;
      }
      /**
       * <pre>
       * Time after system boot when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_boot = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsAfterBoot() {
        copyOnWrite();
        instance.clearMsAfterBoot();
        return this;
      }

      /**
       * <pre>
       * Time after last login when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_login = 3;</code>
       * @return Whether the msAfterLogin field is set.
       */
      @java.lang.Override
      public boolean hasMsAfterLogin() {
        return instance.hasMsAfterLogin();
      }
      /**
       * <pre>
       * Time after last login when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_login = 3;</code>
       * @return The msAfterLogin.
       */
      @java.lang.Override
      public long getMsAfterLogin() {
        return instance.getMsAfterLogin();
      }
      /**
       * <pre>
       * Time after last login when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_login = 3;</code>
       * @param value The msAfterLogin to set.
       * @return This builder for chaining.
       */
      public Builder setMsAfterLogin(long value) {
        copyOnWrite();
        instance.setMsAfterLogin(value);
        return this;
      }
      /**
       * <pre>
       * Time after last login when the collection took place, in milliseconds.
       * </pre>
       *
       * <code>optional int64 ms_after_login = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsAfterLogin() {
        copyOnWrite();
        instance.clearMsAfterLogin();
        return this;
      }

      /**
       * <pre>
       * The duration for which the machine was suspended prior to collecting the
       * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 suspend_duration_ms = 5;</code>
       * @return Whether the suspendDurationMs field is set.
       */
      @java.lang.Override
      public boolean hasSuspendDurationMs() {
        return instance.hasSuspendDurationMs();
      }
      /**
       * <pre>
       * The duration for which the machine was suspended prior to collecting the
       * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 suspend_duration_ms = 5;</code>
       * @return The suspendDurationMs.
       */
      @java.lang.Override
      public long getSuspendDurationMs() {
        return instance.getSuspendDurationMs();
      }
      /**
       * <pre>
       * The duration for which the machine was suspended prior to collecting the
       * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 suspend_duration_ms = 5;</code>
       * @param value The suspendDurationMs to set.
       * @return This builder for chaining.
       */
      public Builder setSuspendDurationMs(long value) {
        copyOnWrite();
        instance.setSuspendDurationMs(value);
        return this;
      }
      /**
       * <pre>
       * The duration for which the machine was suspended prior to collecting the
       * sampled profile. Only set when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 suspend_duration_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearSuspendDurationMs() {
        copyOnWrite();
        instance.clearSuspendDurationMs();
        return this;
      }

      /**
       * <pre>
       * Number of milliseconds after a resume that profile was collected. Only set
       * when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 ms_after_resume = 6;</code>
       * @return Whether the msAfterResume field is set.
       */
      @java.lang.Override
      public boolean hasMsAfterResume() {
        return instance.hasMsAfterResume();
      }
      /**
       * <pre>
       * Number of milliseconds after a resume that profile was collected. Only set
       * when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 ms_after_resume = 6;</code>
       * @return The msAfterResume.
       */
      @java.lang.Override
      public long getMsAfterResume() {
        return instance.getMsAfterResume();
      }
      /**
       * <pre>
       * Number of milliseconds after a resume that profile was collected. Only set
       * when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 ms_after_resume = 6;</code>
       * @param value The msAfterResume to set.
       * @return This builder for chaining.
       */
      public Builder setMsAfterResume(long value) {
        copyOnWrite();
        instance.setMsAfterResume(value);
        return this;
      }
      /**
       * <pre>
       * Number of milliseconds after a resume that profile was collected. Only set
       * when |trigger_event| is RESUME_FROM_SUSPEND.
       * </pre>
       *
       * <code>optional int64 ms_after_resume = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsAfterResume() {
        copyOnWrite();
        instance.clearMsAfterResume();
        return this;
      }

      /**
       * <pre>
       * Number of tabs restored during a session restore. Only set when
       * |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int32 num_tabs_restored = 7;</code>
       * @return Whether the numTabsRestored field is set.
       */
      @java.lang.Override
      public boolean hasNumTabsRestored() {
        return instance.hasNumTabsRestored();
      }
      /**
       * <pre>
       * Number of tabs restored during a session restore. Only set when
       * |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int32 num_tabs_restored = 7;</code>
       * @return The numTabsRestored.
       */
      @java.lang.Override
      public int getNumTabsRestored() {
        return instance.getNumTabsRestored();
      }
      /**
       * <pre>
       * Number of tabs restored during a session restore. Only set when
       * |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int32 num_tabs_restored = 7;</code>
       * @param value The numTabsRestored to set.
       * @return This builder for chaining.
       */
      public Builder setNumTabsRestored(int value) {
        copyOnWrite();
        instance.setNumTabsRestored(value);
        return this;
      }
      /**
       * <pre>
       * Number of tabs restored during a session restore. Only set when
       * |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int32 num_tabs_restored = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearNumTabsRestored() {
        copyOnWrite();
        instance.clearNumTabsRestored();
        return this;
      }

      /**
       * <pre>
       * Number of milliseconds after a session restore that a profile was
       * collected. Only set when |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int64 ms_after_restore = 8;</code>
       * @return Whether the msAfterRestore field is set.
       */
      @java.lang.Override
      public boolean hasMsAfterRestore() {
        return instance.hasMsAfterRestore();
      }
      /**
       * <pre>
       * Number of milliseconds after a session restore that a profile was
       * collected. Only set when |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int64 ms_after_restore = 8;</code>
       * @return The msAfterRestore.
       */
      @java.lang.Override
      public long getMsAfterRestore() {
        return instance.getMsAfterRestore();
      }
      /**
       * <pre>
       * Number of milliseconds after a session restore that a profile was
       * collected. Only set when |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int64 ms_after_restore = 8;</code>
       * @param value The msAfterRestore to set.
       * @return This builder for chaining.
       */
      public Builder setMsAfterRestore(long value) {
        copyOnWrite();
        instance.setMsAfterRestore(value);
        return this;
      }
      /**
       * <pre>
       * Number of milliseconds after a session restore that a profile was
       * collected. Only set when |trigger_event| is RESTORE_SESSION.
       * </pre>
       *
       * <code>optional int64 ms_after_restore = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearMsAfterRestore() {
        copyOnWrite();
        instance.clearMsAfterRestore();
        return this;
      }

      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      @java.lang.Override
      public boolean hasPerfData() {
        return instance.hasPerfData();
      }
      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.PerfDataProtos.PerfDataProto getPerfData() {
        return instance.getPerfData();
      }
      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      public Builder setPerfData(org.chromium.components.metrics.PerfDataProtos.PerfDataProto value) {
        copyOnWrite();
        instance.setPerfData(value);
        return this;
        }
      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      public Builder setPerfData(
          org.chromium.components.metrics.PerfDataProtos.PerfDataProto.Builder builderForValue) {
        copyOnWrite();
        instance.setPerfData(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      public Builder mergePerfData(org.chromium.components.metrics.PerfDataProtos.PerfDataProto value) {
        copyOnWrite();
        instance.mergePerfData(value);
        return this;
      }
      /**
       * <pre>
       * Sampled profile data collected from Linux perf tool.
       * </pre>
       *
       * <code>optional .metrics.PerfDataProto perf_data = 4;</code>
       */
      public Builder clearPerfData() {  copyOnWrite();
        instance.clearPerfData();
        return this;
      }

      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      @java.lang.Override
      public boolean hasCallStackProfile() {
        return instance.hasCallStackProfile();
      }
      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile getCallStackProfile() {
        return instance.getCallStackProfile();
      }
      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      public Builder setCallStackProfile(org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile value) {
        copyOnWrite();
        instance.setCallStackProfile(value);
        return this;
        }
      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      public Builder setCallStackProfile(
          org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile.Builder builderForValue) {
        copyOnWrite();
        instance.setCallStackProfile(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      public Builder mergeCallStackProfile(org.chromium.components.metrics.CallStackProfileProtos.CallStackProfile value) {
        copyOnWrite();
        instance.mergeCallStackProfile(value);
        return this;
      }
      /**
       * <pre>
       * Sampled profile data collected by periodic sampling of call stacks.
       * </pre>
       *
       * <code>optional .metrics.CallStackProfile call_stack_profile = 9;</code>
       */
      public Builder clearCallStackProfile() {  copyOnWrite();
        instance.clearCallStackProfile();
        return this;
      }

      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      @java.lang.Override
      public boolean hasPerfStat() {
        return instance.hasPerfStat();
      }
      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      @java.lang.Override
      public org.chromium.components.metrics.PerfStat.PerfStatProto getPerfStat() {
        return instance.getPerfStat();
      }
      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      public Builder setPerfStat(org.chromium.components.metrics.PerfStat.PerfStatProto value) {
        copyOnWrite();
        instance.setPerfStat(value);
        return this;
        }
      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      public Builder setPerfStat(
          org.chromium.components.metrics.PerfStat.PerfStatProto.Builder builderForValue) {
        copyOnWrite();
        instance.setPerfStat(builderForValue.build());
        return this;
      }
      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      public Builder mergePerfStat(org.chromium.components.metrics.PerfStat.PerfStatProto value) {
        copyOnWrite();
        instance.mergePerfStat(value);
        return this;
      }
      /**
       * <pre>
       * Perf counter data collected using "perf stat".
       * </pre>
       *
       * <code>optional .metrics.PerfStatProto perf_stat = 10;</code>
       */
      public Builder clearPerfStat() {  copyOnWrite();
        instance.clearPerfStat();
        return this;
      }

      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @return A list containing the cpuMaxFrequencyMhz.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getCpuMaxFrequencyMhzList() {
        return java.util.Collections.unmodifiableList(
            instance.getCpuMaxFrequencyMhzList());
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @return The count of cpuMaxFrequencyMhz.
       */
      @java.lang.Override
      public int getCpuMaxFrequencyMhzCount() {
        return instance.getCpuMaxFrequencyMhzCount();
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @param index The index of the element to return.
       * @return The cpuMaxFrequencyMhz at the given index.
       */
      @java.lang.Override
      public int getCpuMaxFrequencyMhz(int index) {
        return instance.getCpuMaxFrequencyMhz(index);
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @param value The cpuMaxFrequencyMhz to set.
       * @return This builder for chaining.
       */
      public Builder setCpuMaxFrequencyMhz(
          int index, int value) {
        copyOnWrite();
        instance.setCpuMaxFrequencyMhz(index, value);
        return this;
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @param value The cpuMaxFrequencyMhz to add.
       * @return This builder for chaining.
       */
      public Builder addCpuMaxFrequencyMhz(int value) {
        copyOnWrite();
        instance.addCpuMaxFrequencyMhz(value);
        return this;
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @param values The cpuMaxFrequencyMhz to add.
       * @return This builder for chaining.
       */
      public Builder addAllCpuMaxFrequencyMhz(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        copyOnWrite();
        instance.addAllCpuMaxFrequencyMhz(values);
        return this;
      }
      /**
       * <pre>
       * The maximum frequency in MHz reported for each logical CPU on the device.
       * This is a repeated field, where entry 0 corresponds to core 0, entry 1 to
       * core 1, and so on. The field is optional and populated only for metrics
       * that can use the max frequency to compute a CPU utilization metric, e.g.
       * when measuring CPU cycles.
       * </pre>
       *
       * <code>repeated uint32 cpu_max_frequency_mhz = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearCpuMaxFrequencyMhz() {
        copyOnWrite();
        instance.clearCpuMaxFrequencyMhz();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:metrics.SampledProfile)
    }
    @java.lang.Override
    @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
    protected final java.lang.Object dynamicMethod(
        com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
        java.lang.Object arg0, java.lang.Object arg1) {
      switch (method) {
        case NEW_MUTABLE_INSTANCE: {
          return new org.chromium.components.metrics.SampledProfileProtos.SampledProfile();
        }
        case NEW_BUILDER: {
          return new Builder();
        }
        case BUILD_MESSAGE_INFO: {
            java.lang.Object[] objects = new java.lang.Object[] {
              "bitField0_",
              "triggerEvent_",
              org.chromium.components.metrics.SampledProfileProtos.SampledProfile.TriggerEvent.internalGetVerifier(),
              "msAfterBoot_",
              "msAfterLogin_",
              "perfData_",
              "suspendDurationMs_",
              "msAfterResume_",
              "numTabsRestored_",
              "msAfterRestore_",
              "callStackProfile_",
              "perfStat_",
              "process_",
              org.chromium.components.metrics.ExecutionContextProtos.Process.internalGetVerifier(),
              "thread_",
              org.chromium.components.metrics.ExecutionContextProtos.Thread.internalGetVerifier(),
              "processTypes_",
              ProcessTypesDefaultEntryHolder.defaultEntry,
              org.chromium.components.metrics.ExecutionContextProtos.Process.internalGetVerifier(),
              "threadTypes_",
              ThreadTypesDefaultEntryHolder.defaultEntry,
              org.chromium.components.metrics.ExecutionContextProtos.Thread.internalGetVerifier(),
              "cpuMaxFrequencyMhz_",
            };
            java.lang.String info =
                "\u0001\u000f\u0000\u0001\u0001\u000f\u000f\u0002\u0001\u0000\u0001\u100c\u0000\u0002" +
                "\u1002\u0003\u0003\u1002\u0004\u0004\u1009\t\u0005\u1002\u0005\u0006\u1002\u0006" +
                "\u0007\u1004\u0007\b\u1002\b\t\u1009\n\n\u1009\u000b\u000b\u100c\u0001\f\u100c\u0002" +
                "\r\u0832\u000e\u0832\u000f\u001d";
            return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
        case GET_DEFAULT_INSTANCE: {
          return DEFAULT_INSTANCE;
        }
        case GET_PARSER: {
          com.google.protobuf.Parser<org.chromium.components.metrics.SampledProfileProtos.SampledProfile> parser = PARSER;
          if (parser == null) {
            synchronized (org.chromium.components.metrics.SampledProfileProtos.SampledProfile.class) {
              parser = PARSER;
              if (parser == null) {
                parser =
                    new DefaultInstanceBasedParser<org.chromium.components.metrics.SampledProfileProtos.SampledProfile>(
                        DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
      }
      case GET_MEMOIZED_IS_INITIALIZED: {
        return (byte) 1;
      }
      case SET_MEMOIZED_IS_INITIALIZED: {
        return null;
      }
      }
      throw new UnsupportedOperationException();
    }


    // @@protoc_insertion_point(class_scope:metrics.SampledProfile)
    private static final org.chromium.components.metrics.SampledProfileProtos.SampledProfile DEFAULT_INSTANCE;
    static {
      SampledProfile defaultInstance = new SampledProfile();
      // New instances are implicitly immutable so no need to make
      // immutable.
      DEFAULT_INSTANCE = defaultInstance;
      com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(
        SampledProfile.class, defaultInstance);
    }

    public static org.chromium.components.metrics.SampledProfileProtos.SampledProfile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static volatile com.google.protobuf.Parser<SampledProfile> PARSER;

    public static com.google.protobuf.Parser<SampledProfile> parser() {
      return DEFAULT_INSTANCE.getParserForType();
    }
  }


  static {
  }

  // @@protoc_insertion_point(outer_class_scope)
}
